#|

 CS 2800 Homework 9 - Fall 2023

 - Due on Tuesday, Nov. 21 by 11:00 PM.

 - You will have to work in groups. Groups should consist of 2-3
   people. Make sure you are in exactly 1 group!  Use the
   piazza "search for teammates" post to find teammates. Please give
   students who don't have a team a home. If you can't find a team ask
   Ankit for help on Piazza. 

 - You will submit your hwk via gradescope. Instructions on how to
   do that are on Piazza. If you need help, ask on Piazza.

 - Submit this file, on Gradescope. After clicking on "Upload", you
   must add your group members to the submission by clicking on "Add
   Group Member" and then filling their names. Every group member can
   submit the homework and we will only grade the last submission. You
   are responsible for making sure that your group submits the right
   version of the homework for your final submission. We suggest you
   submit early and often. Also, you will get feedback on some
   problems when you submit. However, this feedback does not determine
   your final grade, as we will manually review
   submissions. Submission will be enabled a few days after the
   homework is released, but well before the deadline.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 For this homework you will need to use the ACL2s proof checker.
 But, you might want to use ACL2s to check properties you come up
 with.

|#

#|

 You accepted a return offer with your compiler wizard mentor,
 congrats.
 
 She gives you an update on the AI project. There are lots of bugs,
 but she doesn't have much to do, since you helped her verify her
 optimizations last time and she continued doing so for all her new
 optimizations. That was a great idea because every bug that has been
 discovered is the AI team's problem.

 Given that there are no fires to put out, she wants you to have a fun
 starter project. She mentions that during her PhD work on compilers,
 she read a paper with the "sexiest compiler optimazation" she ever
 saw. It converted insertion sort into quicksort! She wants you to
 explore that idea in ACL2s.

 You pull out your RAP book and start playting with the relevant
 definitions for isort (insertion sort). 

|#

(defdata lor (listof rational))

(definec orderedp (x :lor) :bool
  (v (endp (cdr x))
     (^ (<= (car x) (second x))
        (orderedp (cdr x)))))

(definec del (e :rational x :lor) :lor
  (cond ((endp x) nil)
        ((equal e (car x)) (cdr x))
        (t (cons (car x) (del e (cdr x))))))

(definec permp (x y :lor) :bool
  (if (endp x)
      (endp y)
    (^ (in (car x) y)
       (permp (cdr x) (del (car x) y)))))

(definec insert (a :rational x :lor) :lor
  (cond ((endp x) (list a))
        ((<= a (car x)) (cons a x))
        (t (cons (car x) (insert a (cdr x))))))

(definec isort (x :lor) :lor
  (if (endp x)
      ()
    (insert (car x) (isort (cdr x)))))

; This isn't needed, as sort-ordered will go through automatically,
; but this is a good helper theorem to have around and avoids nested
; induction proofs for sort-ordered.
(property orderedp-insert (x :rational l :lor)
  :hyps (orderedp l)
  (orderedp (insert x l)))

(property isort-ordered (x :lor)
  (orderedp (isort x)))

(property isort-permp (x :lor)
  (permp (isort x) x))

#|

 Next you define qsort (quicksort) as follows.

|#

(definec less (a :rational x :lor) :lor
  (cond ((endp x) x)
        ((< (car x) a)
         (cons (car x) (less a (cdr x))))
        (t (less a (cdr x)))))

(definec notless (a :rational x :lor) :lor
  (cond ((endp x) x)
        ((<= a (car x))
         (cons (car x) (notless a (cdr x))))
        (t (notless a (cdr x)))))

(definec ap (x y :tl) :tl
  (if (endp x)
      y
    (cons (car x) (ap (cdr x) y))))

(property ap-assoc (x y z :tl)
  (== (ap (ap x y) z)
      (ap x (ap y z))))

(property ap-nil (x :tl)
  (== (ap x nil) x))

; Lookup sig in RAP
; This rule implies that if we append two lists of type :lor,
; then the result is of type :lor.
(sig ap ((listof :a) (listof :a)) => (listof :a))

(definec qsort (x :lor) :lor
  (if (endp x)
      x 
    (ap (qsort (less (car x) (cdr x)))
        (cons (car x)
              (qsort (notless (car x) (cdr x)))))))

#|

 You meet with her and propose proving the following theorems.

 (property qsort-orderedp (x :lor)
   (orderedp (qsort x)))

 (property qsort-permp (x :lor)
   (permp (qsort x) x))

 In your next sync up, she tells you that the way her sorting
 algorithm will work will be a bit more complicated. When the list to
 sort becomes small enough, qsort will revert to using isort, since
 that turns out to be faster!

 So, she also wants you to prove

 (property qsort=isort (x :lor)
   (== (qsort x)
       (isort x)))
|#

#|

 You go off to start proving the theorem above in order, but then you
 recall Pete's advice:

 1. Days of proof hacking can save you hours of thinking. 
 2. Months of proof hacking can save you days of thinking. 

 So, you think and realize, hey if I prove qsort=isort, then the other
 theorem are trivial and can be proved using equational reasoning!
 
 Therefore, you try proving qsort=isort first, obviously.

 How will you prove qsort=isort? Induction, obviously.

 What scheme? Who knows? But you know the professional method and
 remember that much of the power of the professional method is the
 ability to start a proof without knowing what you're doing. You delay
 decisions for as long as possible and focus on the interesting parts.

 You don't want to do a lot of writing, so you start with some
 some abbreviations.

  A is ap,  Q is qsort,   L is less,    F is first,
  R is rest, N is notless, In is insert, I is isort

 Here we go with the interesting case.  
  
   (A (Q (L (F x) (R x))) (cons (F x) (Q (N (F x) (R x)))))
 = (In (F x) (I (R x)))

 You can assume (by induction) that 
 (Q (L (F x) (R x))) = (I (L (F x) (R x)))
 (Q (N (F x) (R x))) = (I (N (F x) (R x)))

 so now you have to show

   (A (I (L (F x) (R x))) (cons (F x) (I (N (F x) (R x)))))
 = (In (F x) (I (R x)))

 Wow. This is now just a statement about I (isort).
 You gotta love induction and the professional method. 

 Here's a proof sketch (ignoring relevant hypotheses).

 (A (I (L (F x) (R x))) (cons (F x) (I (N (F x) (R x))))) = (In (F x) (I (R x)))
 <== {generalize: replace (F x), (R x) with vars a, l }
 (A (I (L a l)) (cons a (I (N a l)))) = (In a (I l))
 =  {lemmas L1 & L2 to push I inside of L, N}
 (A (L a (I l)) (cons a (N a (I l)))) = (In a (I l))
 <== {generalize: replace (I l) with l, assume l is ordered}
 (A (L a l) (cons a (N a l))) = (In a l)

 So, you have a plan, which is to prove:

 L1: (I (L a l)) = (L a (I l))
 L2: (I (N a l)) = (N a (I l))
 L3: (O l) => (A (L a l) (cons a (N a l))) = (In a l), where O is orderedp
 L4: (O (I l))

 and that should allow you to finish the proof: (make sure
 that you understand the generalizations)

  (A (I (L (F x) (R x))) (cons (F x) (I (N (F x) (R x)))))
 = { L1, L2 }
  (A (L (F x) (I (R x))) (cons (F x) (N (F x) (I (R x)))))
 =  { L3, L4 }
  (In (F x) (R x))
 =  { Def I }
  (I x)

 Notice that L3 essentially tells you something interesting about
 qsort. It tells you that in the recursive case, qsort inserts (F x)
 into the sorted list!

 Also, we already have L4, so no need to prove that!

 To summarize, you will prove qsort=isort, without using permp.  This
 is interesting because it is an approach to specification based on
 refinement. It is conceptually easier to see that any sorting
 algorithm that is equivalent to isort is a sorting
 algorithm. Consider that students in CS2800 have difficulty coming up
 with permp, but less difficulty with defining isort.  The idea with
 refinement is that a spec is just the simplest function definition
 that does what you want it to. An advantage is that you don't need to
 argue that it is a complete spec, e.g., in our case, insertion sort
 is complete, as given any legal input it defines exactly what the
 output should be.

 If we want to base the specification for sorting on ordered
 permutations, how do we know that that is a complete specification?
 Well, we can prove that, but that requires a fair amount of work.

 Refinement is a very natural way of specifying correctness and the
 theory of refinement is very interesting, especially when you get to
 reactive systems (like network protocols, operating systems, etc).

 Finish the proof using the proof checker by proving lemmas L1, L2, L3,
 qsort=isort, qsort-orderedp and qsort-permp.

 You will need some extra lemmas (helper theorems).

|#
Lemma L1:
(=>
  (^ (rationalp a) (lorp l))
    (=> (^ (rationalp a) (lorp l))
  (== (isort (less a l)) (less a (isort l)))))
    
proof by: induction on (lorp l)

Base Case 0:
(IMPLIES (AND (NOT (ATOM L)) (NOT (RATIONALP (CAR L))))
          (IMPLIES (AND (RATIONALP A) (RATIONAL-LISTP L))
                   (IMPLIES (AND (RATIONALP A) (RATIONAL-LISTP L))
                            (EQUAL (ISORT (LESS A L)) (LESS A (ISORT L))))))

Exportation:
(=>
  (^ (rationalp a) (lorp l) (! (lorp l)))
    (== (isort (less a l)) (less a (isort l))))
    
Context:
C1. (rationalp a)
C2. (lorp l)
C3. (! (lorp l))

Derived Context:
D1. nil { C2, C3 }
QED

Base Case 1:
 (IMPLIES (ATOM L)
          (IMPLIES (AND (RATIONALP A) (RATIONAL-LISTP L))
                   (IMPLIES (AND (RATIONALP A) (RATIONAL-LISTP L))
                            (EQUAL (ISORT (LESS A L)) (LESS A (ISORT L))))))

Exportation:
(=> (^ (lorp l) (endp l) (rationalp a))
	  (== (isort (less a l)) (less a (isort l))))
	
Context:
C1. (lorp l)
C2. (endp l)
C3. (rationalp a)

Goal:
(== (isort (less a l)) (less a (isort l)))

Proof:
(== (isort (less a l)) (less a (isort l)))
== {def less,C2 }
(== (isort l) (less a (isort l)))
== {def isort, C2}
(== nil (less a nil))
== {def less, eval}
(== nil nil)

QED

Induction Case 1:
(IMPLIES
  (AND (NOT (ATOM L)) (RATIONALP (CAR L))
       (IMPLIES (AND (RATIONALP A) (RATIONAL-LISTP (CDR L)))
                (IMPLIES (AND (RATIONALP A) (RATIONAL-LISTP (CDR L)))
                         (EQUAL (ISORT (LESS A (CDR L)))
                                (LESS A (ISORT (CDR L)))))))
  (IMPLIES (AND (RATIONALP A) (RATIONAL-LISTP L))
           (IMPLIES (AND (RATIONALP A) (RATIONAL-LISTP L))
           	                    (EQUAL (ISORT (LESS A L)) (LESS A (ISORT L))))))

Exportation: 
(=> (^ (rationalp a) (lorp l) (! (endp l))
	(=> (lorp (cdr l))
		(== (isort (less a (cdr l))) (less a (isort (cdr l))))))
	(== (isort (less a l)) (less a (isort l))))

Context:
C1. (rationalp a)
C2. (lorp l)
C3. (! (endp l))
C4. (=> (lorp (cdr l))
		(== (isort (less a (cdr l))) (less a (isort (cdr l)))))

Derived Context:
D1.(== (isort (less a (cdr l))) (less a (isort (cdr l)))) { C4, MP }

Goal:
(== (isort (less a l)) (less a (isort l)))

Proof: 
(less a (isort l))
== {def isort, C3}
(less a (insert (car l) (isort (cdr l))))
== {def insert }
(less a ())
QED
QED

lemma L2:
(=> (^ (lorp x) (rationalp a))
  (== (isort (notless a x)) (notless a (isort x)))
)

proof by: Induction on (lorp x)

Base Case 0:
(IMPLIES (AND (NOT (ATOM X)) (NOT (RATIONALP (CAR X))))
          (IMPLIES (AND (RATIONAL-LISTP X) (RATIONALP A))
                   (EQUAL (ISORT (NOTLESS A X)) (NOTLESS A (ISORT X)))))
                          
Exportation:
(=> (^ (! (lorp x)) (lorp x) (rationalp a))
	(== (isort (notless a x)) (notless a (isort x)))
)
Context: 
C1. (! (lorp x))
C2. (lorp x)
C3. (rationalp a)

Derived Context:
D1. nil {C1, C2}
QED

Base Case 1:
 (IMPLIES (ATOM X)
          (IMPLIES (AND (RATIONAL-LISTP X) (RATIONALP A))
                   (EQUAL (ISORT (NOTLESS A X)) (NOTLESS A (ISORT X)))))

Exportation:
(=> (^ (lorp x) (endp x) (rationalp a))
	(== (isort (notless a x)) (notless a (isort x)))
)

Context: 
C1. (lorp x)
C2. (endp x)
C3. (rationalp a)

Derived Context:

Goal:
(== (isort (notless a x)) (notless a (isort x)))

proof:
(== (isort (notless a x)) (notless a (isort x)))

QED

Induction Case 1:
(IMPLIES
  (AND (NOT (ATOM X)) (RATIONALP (CAR X))
       (IMPLIES (AND (RATIONAL-LISTP (CDR X)) (RATIONALP A))
                (EQUAL (ISORT (NOTLESS A (CDR X)))
                       (NOTLESS A (ISORT (CDR X))))))
  (IMPLIES (AND (RATIONAL-LISTP X) (RATIONALP A))
           (EQUAL (ISORT (NOTLESS A X)) (NOTLESS A (ISORT X)))))

Exportation:
(=> (^ (lorp x) (! (endp x)) (rationalp a)
	(=> (lorp (cdr x))
		(== (isort (notless a (cdr x)))
			(notless a (isort (cdr x))))))
	(== (isort (notless a x))
		(notless a x)))

Context:
C1. (lorp x)
C2. (! (endp x))
C3. (rationalp a)
C4. (=> (lorp (cdr x))
		(== (isort (notless a (cdr x)))
			(notless a (isort (cdr x)))))

Derived Context:
D1. (== (isort (notless a (cdr x)))
			(notless a (isort (cdr x)))) {C4, MP}

Goal: 
(== (isort (notless a x))
		(notless a (isort cdr x)))
		
Proof:
(== (isort (notless a x))
		(notless a (isort cdr x)))

QED
QED

Lemma insert-nl:
(=>
  (^ (rationalp b) (rationalp a) (lorp l))
  (== (insert b (notless a l)) (notless a (insert b l)))
)


Proof by: Induction on (insert b l)

Base Case 0:
(IMPLIES (NOT (AND (RATIONALP B) (RATIONAL-LISTP L)))
          (IMPLIES (AND (RATIONALP B) (RATIONALP A) (RATIONAL-LISTP L))
                   (EQUAL (INSERT B (NOTLESS A L)) (NOTLESS A (INSERT B L)))))
                   
Exportation:
(=>
  (^ (! (^ (rationalp b) (lorp l)))
  (rationalp b ) (rationalp a) (lorp l))
  (== (insert b (notless a l)) (notless a (insert b l)))
)

Context:
C1. (! (^ (rationalp b) (lorp l)))
C2. (rationalp b)
C3. (rationalp a)
C4. (lorp l)

Derived Context:
D1. nil {C1, C2, C4}
QED

Induction Case 1:
(IMPLIES
  (AND (AND (RATIONALP B) (RATIONAL-LISTP L)) (NOT (ENDP L)) (< (CAR L) B)
       (IMPLIES (AND (RATIONALP B) (RATIONALP A) (RATIONAL-LISTP (CDR L)))
                (EQUAL (INSERT B (NOTLESS A (CDR L)))
                       (NOTLESS A (INSERT B (CDR L))))))
  (IMPLIES (AND (RATIONALP B) (RATIONALP A) (RATIONAL-LISTP L))
           (EQUAL (INSERT B (NOTLESS A L)) (NOTLESS A (INSERT B L)))))
           
Exportation:
(=>
  (^
    (rationalp b) (lorp l) (! (endp l)) (< (car l) b)
    (=> (^ (rationalp b) (rationalp a) (lorp (cdr l)))
      (== (insert b (notless a (cdr l)))
        (notless a (insert b (cdr l)))
      )
    )
    (rationalp a)
  )
  (== (insert b (notless a l)) (notless a (insert b l)))
)

Context:
C1. (rationalp b)
C2. (lorp l)
C3. (! (endp l))
C4. (< (car l) b)
C5. (=> (^ (rationalp b) (rationalp a) (lorp (cdr l)))
    (== (insert b (notless a (cdr l)))
      (notless a (insert b (cdr l)))
    )
)
C6. (rationalp a)

Derived Context:
D1. (lorp (cdr l)) {C2, C3}
D2. (== (insert b (notless a (cdr l)))
    (notless a (insert b (cdr l)))
) {D1, C1, C6, C5, mp}

Goal:(== (insert b (notless a l)) (notless a (insert b l)))

Proof:
(== (insert b (notless a l)) (notless a (insert b l)))
== {def insert, C4}
(== (insert b (notless a l)) (notless a (cons (car l) (insert b (cdr l)))))

QED
QED

Lemma L2-sean:
(=>
  (^ (rationalp a) (lorp l))
  (== (isort (notless a l)) (notless a (isort l)))
)

Proof by: Induction on (notless a l)

Base Case 0:
(=>
  (! (lorp l))
  (=>
  (^ (rationalp a) (lorp l))
  (== (isort (notless a l)) (notless a (isort l)))
)
)

Exportation:
(=>
  (^ (! (lorp l)) (rationalp a) (lorp l))
  (== (isort (notless a l)) (notless a (isort l)))
)

Context:
C1. (! (lorp l))
C2. (rationalp a)
C3. (lorp l)

Derived Context:
D1. nil {C1, C3}

QED


Base Case 1:
(=>
  (^ (lorp l) (endp l))
  (=>
  (^ (rationalp a) (lorp l))
  (== (isort (notless a l)) (notless a (isort l)))
)
)

Exportation:
(=>
  (^ (lorp l) (endp l) (rationalp a))
  (== (isort (notless a l)) (notless a (isort l)))
)

Context:
C1. (lorp l)
C2. (endp l)
C3. (rationalp a)

Goal:
(== (isort (notless a l)) (notless a (isort l)))

Proof:
(== (isort (notless a l)) (notless a (isort l)))
== {def notless, C2}
(== (isort l) (notless a (isort l)))
== {def isort, C2}
(== nil (notless a (isort l)))
== {def isort, C2}
(== nil (notless a nil))
== {def notless, eval}
(== nil nil)

QED

Induction Case 1:
(=>
  (^ (^ (rationalp a) (lorp l)) (! (endp l)) (<= a (car l))
       (=> (^ (rationalp a) (lorp (cdr l)))
                (== (isort (notless a (cdr l)))
                       (notless a (isort (cdr l))))))
  (=> (^ (rationalp a) (lorp l))
           (== (isort (notless a l)) (notless a (isort l)))))
           
Exportation:
(=>
  (^ (rationalp a) (lorp l) (! (endp l)) (<= a (car l))
    (=> (^ (rationalp a) (lorp (cdr l)))
                (== (isort (notless a (cdr l)))
                       (notless a (isort (cdr l)))))
  )
  (== (isort (notless a l)) (notless a (isort l)))
)

Context:
C1. (rationalp a)
C2. (lorp l)
C3. (! (endp l))
C4. (<= a (car l))
C5. (=> (^ (rationalp a) (lorp (cdr l)))
                (== (isort (notless a (cdr l)))
                       (notless a (isort (cdr l)))))
                       
Derived Context:
D1. (lorp (cdr l)) {C2, C3}
D2. (== (isort (notless a (cdr l)))
                       (notless a (isort (cdr l)))) {D1, C1, C5, mp}

Goal:
(== (isort (notless a l)) (notless a (isort l)))

Proof:
(== (isort (notless a l)) (notless a (isort l)))
== {def notless, C3, C4}
(== (isort (cons (car l) (notless a (cdr l)))) (notless a (isort l)))
== {def isort, cons axioms}
(== (insert (car l) (isort (notless a (cdr l)))) (notless a (isort l)))
== {D2}
(== (insert (car l) (notless a (isort (cdr l)))) (notless a (isort l)))
== {def isort, C3}
(== (insert (car l) (notless a (isort (cdr l)))) (notless a (insert (car l) (isort (cdr l)))))


QED
QED

lemma L3:
(=> (^ (lorp x) (rationalp a))
  (=> (orderedp x)
    (== (ap (less a x) (cons a (notless a x)))
    	(insert a x)
    )))

proof by: induction on (lorp x)

Base Case 0:
(IMPLIES (AND (NOT (ATOM X)) (NOT (RATIONALP (CAR X))))
          (IMPLIES (AND (RATIONAL-LISTP X) (RATIONALP A))
                   (IMPLIES (ORDEREDP X)
                            (EQUAL (AP (LESS A X) (CONS A (NOTLESS A x)))
                                   (INSERT A x)))))

Exportation:
(=> (^ (! (lorp x))
	   (lorp x)
	   (rationalp a)
       (orderedp x))
  (== (ap (less a x) (cons a (notless a x))) (insert a x))
)

Context:
C1. (lorp x)
C2. (! (lorp x))
C3. (rationalp a)
C4. (orderedp x)

Derived Context:
D1. nil {C1, C2}

QED
Base Case 1:
 (IMPLIES (ATOM X)
          (IMPLIES (AND (RATIONAL-LISTP X) (RATIONALP A))
                   (IMPLIES (ORDEREDP X)
                            (EQUAL (AP (LESS A X) (CONS A (NOTLESS A x)))
                                   (INSERT A x)))))

Exportation:
(=> (^ (lorp x) (endp x) (rationalp a) (orderedp x))
    (== (ap (less a x) (cons a (notless a x))) (insert a x))
)
   
Context:
C1. (lorp x)
C2. (endp x)
C3. (rationalp a)
C4. (orderedp x)

Derived Context:

Goal:                        
(== (ap (less a x) (cons a (notless a x))) (insert a x))
    
proof:                         
(== (ap (less a x) (cons a (notless a x))) (insert a x))

QED
Induction Case 1:
(IMPLIES
  (AND (NOT (ATOM X)) (RATIONALP (CAR X))
       (IMPLIES (AND (RATIONAL-LISTP (CDR X)) (RATIONALP A))
                (IMPLIES (ORDEREDP (CDR X))
                         (EQUAL
                          (AP (LESS A (CDR X)) (CONS A (NOTLESS A (CDR X))))
                          (INSERT A (CDR X))))))
  (IMPLIES (AND (RATIONAL-LISTP X) (RATIONALP A))
           (IMPLIES (ORDEREDP X)
                    (EQUAL (AP (LESS A X) (CONS A (NOTLESS A X)))
                           (INSERT A X)))))
                           
Exportation:
(=> (^ (lorp x) (rationalp a) (! (endp x)) (orderedp x)
	(=> (orderedp (cdr x))
		(== (ap (less a (cdr x)) (cons a (notless a (cdr x))))
			(insert a (cdr x)))))
	(== (ap (less a x) (cons a (notless a x)))
		(insert a x)))

Context: 
C1. (lorp x)
C2. (rationalp a)
C3. (! (endp x))
C4. (orderedp x)
C5. (=> (orderedp (cdr x))
		(== (ap (less a (cdr x)) (cons a (notless a (cdr x))))
			(insert a (cdr x))))

Derived Context:
D1. (== (ap (less a (cdr x)) (cons a (notless a (cdr x))))
			(insert a (cdr x))) { C5, MP }

Goal: 
(== (ap (less a x) (cons a (notless a x)))
		(insert a x))

QED
QED

lemma q=isort:
(=> (lorp x)
  (== (qsort x) (isort x)))

proof by: induction on (lorp x)

Base Case 0:
(=> (! (lorp x))
  (=> (lorp x)
    (== (qsort x) (isort x))
  )
)

Exportation:
(=> (^ (! (lorp x))
  (lorp x))
  (== qsort x) (isort x))

Context:
C1. (! (lorp x))
C2. (lorp x)

Derived Context:
D1. nil {C1, C2}

QED

QED

#|

 Extra Credit (75 hwk points)
 
 Define msort, mergesort on rationals and prove (in the proof checker)

 (property msort=qsort (l :lor)
   (== (msort l)
       (qsort l)))

|#
