(definec in (a :all x :tl) :bool
  (and (consp x)
       (or (== a (car x))
           (in a (cdr x)))))

(definec ap (x y :tl) :tl
  (if (endp x)
      y
    (cons (car x) (ap (cdr x) y))))

(definec rv (x :tl) :tl
  (if (endp x)
      x
    (ap (rv (cdr x)) (list (car x)))))

(definec rem-dups (x :tl) :tl
  (cond ((endp x) x)
        ((in (car x) (cdr x))
         (rem-dups (cdr x)))
        (t (cons (car x) (rem-dups (cdr x))))))

; You get this property for free, since we did it in class.  See
; l26.proof for the proof checker proof. You will have to do similar
; proofs for this homework.

(property ap-assoc (x y z :tl)
  (== (ap (ap x y) z)
      (ap x (ap y z))))

; The first two lemmas are proof checker proofs of in-ap using
; different induction schemes.

Lemma in-ap1:
(=> (^ (tlp x) (tlp y))
    (== (in a (ap x y))
        (v (in a x) (in a y))))

Proof by: Induction on (in a x)

Base Case 0:
(=> (! (tlp x))
    (=> (^ (tlp x) (tlp y))
    (== (in a (ap x y))
        (v (in a x) (in a y)))))
        
Exportation:
(=> (^ (! (tlp x))
       (tlp x)
       (tlp y))
    (== (in a (ap x y))
        (v (in a x) (in a y))))
        
Context:
C1. (! (tlp x))
C2. (tlp x)
C3. (tlp y)

Derived Context:
D1. nil {C1, C2}

QED

Base Case 1:
(=> (^ (tlp x) (! (consp x)))
    (=> (^ (tlp x) (tlp y))
    (== (in a (ap x y))
        (v (in a x) (in a y)))))

Exportation:
(=>
    (^
        (tlp x)
        (! (consp x))
        (tlp y))
    (== (in a (ap x y))
        (v (in a x) (in a y))))
        
Context:
C1. (tlp x)
C2. (! (consp x))
C3. (tlp y)

Goal: (== (in a (ap x y))
        (v (in a x) (in a y)))

Proof:
(== (in a (ap x y))
        (v (in a x) (in a y)))
== {def ap, C2}
(== (in a y)
        (v (in a x) (in a y)))
== {def in, C2}
(== (in a y)
        (v nil (in a y)))
== {pl}
(== (in a y)
        (in a y))

QED

Base Case 2:
(=> (^
        (tlp x)
        (consp x)
        (== a (car x)))
    (=> (^ (tlp x) (tlp y))
        (== (in a (ap x y))
            (v (in a x) (in a y)))))
            
Exportation:
(=>
    (^
        (tlp x)
        (consp x)
        (==  a (car x))
        (tlp y))
   (== (in a (ap x y))
            (v (in a x) (in a y))))
            
Context:
C1. (tlp x)
C2. (consp x)
C3. (== a (car x))
C4. (tlp y)

Goal:
(== (in a (ap x y))
            (v (in a x) (in a y)))

Proof:
(== (in a (ap x y))
            (v (in a x) (in a y)))
== {def ap, C2, cons axioms}
(== (in a (cons (car x) (ap (cdr x) y)))
            (v (in a x) (in a y)))
== {def in, cons axioms, C3}            
(== t
            (v (in a x) (in a y)))
== {def in, C2, C3}
(== t
            (v t (in a y)))
== {pl}
(== t t)
QED

Induction Case 1:
(=>
    (^
        (tlp x)
        (consp x)
        (! (== a (car x)))
        (=> (^ (tlp (cdr x)) (tlp y))
            (== (in a (ap (cdr x) y))
                (v (in a (cdr x)) (in a y)))))
    (=> (^ (tlp x) (tlp y))
        (== (in a (ap x y))
            (v (in a x) (in a y)))))
            
Exportation:
(=>
    (^
        (tlp x)
        (consp x)
        (! (== a (car x)))
        (=> (^ (tlp (cdr x)) (tlp y))
            (== (in a (ap (cdr x) y))
                (v (in a (cdr x)) (in a y))))
        (tlp y))
    (== (in a (ap x y))
            (v (in a x) (in a y))))

Context:
C1. (tlp x)
C2. (consp x)
C3. (! (== a (car x)))
C4. (=> (^ (tlp (cdr x)) (tlp y))
            (== (in a (ap (cdr x) y))
                (v (in a (cdr x)) (in a y))))
C5. (tlp y)

Derived Context:
D1. (tlp (cdr x)) {C1, C2, def tlp}
D2. (== (in a (ap (cdr x) y))
                (v (in a (cdr x)) (in a y))) {D1, C5, C4, mp}

Goal:
(== (in a (ap x y))
            (v (in a x) (in a y)))
Proof:
(== (in a (ap x y))
            (v (in a x) (in a y)))
== {def ap, C2} 
(== (in a (cons (car x) (ap (cdr x) y)))
            (v (in a x) (in a y)))
== {def in}
(== (and (consp (cons (car x) (ap (cdr x) y)))
       (or (== a (car (cons (car x) (ap (cdr x) y))))
           (in a (cdr (cons (car x) (ap (cdr x) y))))))
            (v (in a x) (in a y)))
== {def consp}
(== (and t
       (or (== a (car (cons (car x) (ap (cdr x) y))))
           (in a (cdr (cons (car x) (ap (cdr x) y))))))
            (v (in a x) (in a y)))
== {pl}
(== (or (== a (car (cons (car x) (ap (cdr x) y))))
           (in a (cdr (cons (car x) (ap (cdr x) y)))))
            (v (in a x) (in a y)))
== {cons axioms}
(== (or (== a (car x))
           (in a (ap (cdr x) y)))
            (v (in a x) (in a y)))
== {C3}
(== (or nil
           (in a (ap (cdr x) y)))
            (v (in a x) (in a y)))
== {pl}
(== (in a (ap (cdr x) y))
            (v (in a x) (in a y)))
== {D2}
(== (v (in a (cdr x)) (in a y))
            (v (in a x) (in a y)))
== {def in, C2}
(== (v (in a (cdr x)) (in a y))
            (v (v (== a (car x)) (in a (cdr x))) (in a y)))
== {C3, pl}
(== (v (in a (cdr x)) (in a y))
            (v (in a (cdr x)) (in a y)))
QED
QED

Lemma in-ap2:
(=> (^ (tlp x) (tlp y))
    (== (in a (ap x y))
        (v (in a x) (in a y))))

Proof by: Induction on (tlp x)

Base Case 0:
(=> (! (consp x))
    (=> (^ (tlp x) (tlp y))
    (== (in a (ap x y))
        (v (in a x) (in a y)))))

Exportation:
(=>
    (^
        (! (consp x))
        (tlp x)
        (tlp y))
    (== (in a (ap x y))
        (v (in a x) (in a y))))
        
Context:
C1. (! (consp x))
C2. (tlp x)
C3. (tlp y)

Goal:
(== (in a (ap x y))
        (v (in a x) (in a y)))

Proof:
(== (in a (ap x y))
        (v (in a x) (in a y)))
== {def ap, C1}
(== (in a y)
        (v (in a x) (in a y)))
== {def in, C1}
(== (in a y)
        (v nil (in a y)))
== {pl}
(== (in a y)
    (in a y))
QED

Induction Case 1:
(=> (^
        (consp x)
        (=> (^ (tlp (cdr x)) (tlp y))
            (== (in a (ap (cdr x) y))
                (v (in a (cdr x)) (in a y)))))
    (=> (^ (tlp x) (tlp y))
        (== (in a (ap x y))
            (v (in a x) (in a y)))))
            
Exportation:
(=>
    (^
        (consp x)
        (=> (^ (tlp (cdr x)) (tlp y))
            (== (in a (ap (cdr x) y))
                (v (in a (cdr x)) (in a y))))
        (tlp x)
        (tlp y))
    (== (in a (ap x y))
            (v (in a x) (in a y))))
            
Context:
C1. (consp x)
C2. (=> (^ (tlp (cdr x)) (tlp y))
            (== (in a (ap (cdr x) y))
                (v (in a (cdr x)) (in a y))))
C3. (tlp x)
C4. (tlp y)

Derived Context:
D1. (tlp (cdr x)) {C1, C3}
D2. (== (in a (ap (cdr x) y))
                (v (in a (cdr x)) (in a y))) {D1, C4, C2, mp}
                
Goal:
(== (in a (ap x y))
            (v (in a x) (in a y)))
            
Proof:
(in a (ap x y))
== {def ap, C1}
(in a (cons (car x) (ap (cdr x) y)))
== {def in}
(v (== a (car (cons (car x) (ap (cdr x) y)))) (in a (cdr (cons (car x) (ap (cdr x) y)))))
== {cons axioms}
(v (== a (car x)) (in a (ap (cdr x) y)))
== {D2}
(v (== a (car x)) (v (in a (cdr x)) (in a y)))
== {pl}
(v (v (== a (car x)) (in a (cdr x))) (in a y))
== {def in, C1}
(v (in a x) (in a y))

QED
 
QED
#|

 Which of the following induction schemes is not viable
 to prove Conjecture in-ap2?
 
 1. (ap x y)
 2. (in a y)

 Explain why not by showing where a proof attempt using the non-viable
 induction scheme fails.

 XXX

|#

; Notice that you can use lemmas you have proved in subsequent proofs,
; e.g., you can use in-ap1 in the proof of in-rv or any other subsequent lemma.

Lemma in-rv:
(=> (tlp x)
    (== (in a (rv x))
        (in a x)))

Proof by: Induction on (rv x)

Base Case 0:
(=>
    (! (tlp x))
    (=> (tlp x)
        (== (in a (rv x))
            (in a x)))
)

Exportation:
(=>
    (^
        (! (tlp x))
        (tlp x)
    )
    (== (in a (rv x))
            (in a x))
)

Context:
C1. (! (tlp x))
C2. (tlp x)

Derived Context:
D1. nil {C1, C2}
QED

Base Case 1:
(=>
    (=> (tlp x)
        (endp x))
    (=> (tlp x)
        (== (in a (rv x))
            (in a x))))
            
Exportation:
(=>
    (^
        (=> (tlp x)
            (endp x))
        (tlp x)
    )
    (== (in a (rv x))
            (in a x))
)

Context:
C1. (=> (tlp x)
            (endp x))
C2. (tlp x)

Derived Context:
D1. (endp x) {C2, C1, mp}

Goal: 
(== (in a (rv x))
            (in a x))
            
Proof:
(in a (rv x))
== {D1, def rv}
(in a x)
QED

Induction Case 1:
(=>
    (^
        (=> (tlp x)
            (! (endp x)))
        (tlp x)
        (=> 
            (tlp (cdr x))
            (== (in a (rv (cdr x)))
                (in a (cdr x)))
        )
    )
    (=> (tlp x)
    (== (in a (rv x))
        (in a x)))
)


Exportation:
(=>
    (^
        (=> 
            (tlp x)
            (! (endp x))
        )
        (tlp x)
        (=> 
            (tlp (cdr x))
            (== (in a (rv (cdr x)))
                (in a (cdr x)))
        )
    )
    (== (in a (rv x))
            (in a x))
)

Context:
C1. (=> 
            (tlp x)
            (! (endp x))
        )
C2. (tlp x)
C3. (=> 
            (tlp (cdr x))
            (== (in a (rv (cdr x)))
                (in a (cdr x)))
        )
        
Derived Context:
D1. (! (endp x)) {C1, C2, mp}
D2. (tlp (cdr x)) {C2, D1}
D3. (== (in a (rv (cdr x)))
                (in a (cdr x))) {C3, D2, mp}
                
Goal:
(== (in a (rv x))
            (in a x))
            
Proof:
(in a (rv x))
== {def rv, D1}
(in a (ap (rv (cdr x)) (list (car x))))
== {lemma in-ap1 ((x (rv (cdr x))) (y (list (car x)))), C2, D2}
(v (in a (rv (cdr x))) (in a (list (car x))))
== {D3}
(v (in a (cdr x)) (in a (list (car x))))
== {pl}
(v (in a (list (car x))) (in a (cdr x)))
== {cons axioms}
(v (in a (cons (car x) nil)) (in a (cdr x)))
== {lemma in-ap1 ((x (cons (car x) nil)) (y (cdr x))), D2, cons axioms}
(in a (ap (cons (car x) nil) (cdr x)))
== {cons axioms, def ap}
(in a (cons (car x) (ap nil (cdr x))))
== {def ap}
(in a (cons (car x) (cdr x)))
== {cons axioms, C2, D1}
(in a x)
QED
QED


; This is a proof of in-rem-dups
; Use whatever induction scheme you like.
Lemma in-rem-dups:
(=> (tlp x)
    (== (in a (rem-dups x))
        (in a x)))

Proof by: Induction on (rem-dups x)

Base Case 0:
(=>
    (! (tlp x))
    (=> (tlp x)
        (== (in a (rem-dups x))
            (in a x)))
)

Exportation:
(=>
    (^
        (! (tlp x))
        (tlp x)
    )
    (== (in a (rem-dups x))
            (in a x)))
            
Context:
C1. (! (tlp x))
C2. (tlp x)

Derived Context:
D1. nil {C1, C2}

QED

Base Case 1:
(=>
    (=>
        (tlp x)
        (endp x)
    )
    (=> (tlp x)
        (== (in a (rem-dups x))
            (in a x)))
)

Exportation:
(=>
    (^
        (=>
            (tlp x)
            (endp x)
        )
        (tlp x)
    )
    (== (in a (rem-dups x))
            (in a x)))
            
Context:
C1. (=>
            (tlp x)
            (endp x)
        )
C2. (tlp x)

Derived Context:
D1. (endp x) {C1, C2, mp}

Goal:
(== (in a (rem-dups x))
            (in a x))
            
Proof:
(in a (rem-dups x))
== {def rem-dups, D1}
(in a x)
QED

Induction Case 1:
(=>
    (^
        (=>
            (tlp x)
            (^
                (! (endp x))
                (in (car x) (cdr x))
                (== a (car x))
            )
        )
        (=> (tlp (cdr x))
            (== (in a (rem-dups (cdr x)))
                (in a (cdr x))))
    )
    (=> (tlp x)
        (== (in a (rem-dups x))
            (in a x)))
)

Exportation:
(=>
    (^
        (=>
            (tlp x)
            (^
                (! (endp x))
                (in (car x) (cdr x))
                (== a (car x))
            )
        )
        (=> (tlp (cdr x))
            (== (in a (rem-dups (cdr x)))
                (in a (cdr x))))
        (tlp x)
    )
)

Context:
C1. (=>
            (tlp x)
            (^
                (! (endp x))
                (in (car x) (cdr x))
                (== a (car x))
            )
        )
C2. (tlp x)
C3. (=> (tlp (cdr x))
            (== (in a (rem-dups (cdr x)))
                (in a (cdr x))))

Derived Context:
D1. (! (endp x)) {C1, C2, mp}
D2. (in (car x) (cdr x)) {C1, C2, mp} 
D3. (== a (car x)) {C1, C2, mp}
D4. (tlp (cdr x)) {C2, D1}
D5. (== (in a (rem-dups (cdr x)))
                (in a (cdr x))) {C3, D4, mp}

Goal:
(== (in a (rem-dups x))
            (in a x))

Proof:
(== (in a (rem-dups x))
            (in a x))
== {def rem-dups, D2}
(== (in a (rem-dups (cdr x)))
            (in a x))
== {def in, D1}
(== (in a (rem-dups (cdr x)))
            (and (consp x)
               (or (== a (car x))
                   (in a (cdr x)))))
== {D3}
(== (in a (rem-dups (cdr x)))
            (and (consp x)
               (or t
                   (in a (cdr x)))))
== {pl}
(== (in a (rem-dups (cdr x)))
            (and (consp x)
               t))
== {pl}
(== (in a (rem-dups (cdr x)))
            (consp x))
== {C2, D1}
(== (in a (rem-dups (cdr x)))
            t)
== {pl}
(in a (rem-dups (cdr x)))
== {D5}
(in a (cdr x))
== {D3}
(in (car x) (cdr x))
== {D2}
t

QED
QED
#|
(tlp x)

Base Case 0:
(=>
    (! (consp x))
    (=> (tlp x)
        (== (in a (rem-dups x))
            (in a x)))
)

Exportation:
(=>
    (^
        (! (consp x))
        (tlp x)
    )
    (== (in a (rem-dups x))
            (in a x))
)

Context:
C1. (! (consp x))
C2. (tlp x)

Derived Context:
D1. (endp x) {C1, C2}

Goal:
(== (in a (rem-dups x))
            (in a x))
            
Proof:
(in a (rem-dups x))
== {def rem-dups, D1}
(in a x)

QED

Induction Case 1:
(=>
    (=>
        (consp x)
        (^
        (in (car x) (cdr x))
        (== a (car x))
        (=> (tlp (cdr x))
            (== (in a (rem-dups (cdr x)))
                (in a (cdr x))))
                )
      )
    (=> (tlp x)
        (== (in a (rem-dups x))
            (in a x)))
)

Exportation:
(=>
    (^
        (consp x)
        (in (car x) (cdr x))
        (== a (car x))
        (=> (tlp (cdr x))
            (== (in a (rem-dups (cdr x)))
                (in a (cdr x))))
        (tlp x)
    )
    (== (in a (rem-dups x))
            (in a x))
)

Context:
C1. (consp x)
C2. (in (car x) (cdr x))
C3. (== a (car x))
C4. (=> (tlp (cdr x))
            (== (in a (rem-dups (cdr x)))
                (in a (cdr x))))
C5. (tlp x)

Derived Context:
D1. (tlp (cdr x)) {C1, C5}
D2. (== (in a (rem-dups (cdr x)))
                (in a (cdr x))) {D1, C4, mp}
                
Goal:
(== (in a (rem-dups x))
    (in a x))
    
Proof:
(== (in a (rem-dups x))
    (in a x))
== {def rem-dups, C1, C2}
(== (in a (rem-dups (cdr x)))
    (in a x))
== {D2}
(== (in a (cdr x))
    (in a x))
== {C3}
(== (in (car x) (cdr x))
    (in a x))
== {C2}
(== t
    (in a x))
== {def in, C1}
(== t
    (or (== a (car x))
           (in a (cdr x))))
== {C3}
(== t
    (or (== a (car x))
           (in (car x) (cdr x))))
== {C2}
(== t
    (or (== a (car x))
           t))
== {pl}
(== t t)

QED


#|

 Formalize this property and prove it using the above lemmas.
 Hint: do not use induction, just equational reasoning!

 (property (el :all a b c d :tl)
   (== (in el (rem-dups (rv (rem-dups (rv (ap (rv (ap (rv (ap a b)) (ap a c))) d))))))
       (v (in el a) (in el b) (in el c) (in el d))))

|#

Conjecture sanity-check:

XXX

; Prove the following lemma. You will need helper lemmas.
; Hint: the lecture notes are your friend.
Lemma rv-rv:
(=> (tlp x)
    (== (rv (rv x))
        x))

; Here is another function that your mentor wants you to reason about.
(definec make-n-xs (n :nat x :all) :tl
  (if (zp n)
      nil
    (cons x (make-n-xs (1- n) x))))

; She claims that the following is a theorem you should prove.
; Actually, it isn't a theorem. Think about why and change the RHS as
; little as possible to make this a theorem and prove it. You can only
; change the RHS.
;
; The prove it using whatever induction scheme you like.
Lemma in-make-n-xs
(=> (natp x)
    (== (in a (make-n-xs x y))
        (== a y)))

XXX

; Your mentor is busy building her compiler and you have some free
; time. After doing some LeetCode exercises, you get bored and decide
; to go talk to the AI team. They are building an AI that can solve
; recurrence relations. They gave you a few examples that they want to
; be able to solve.
;
; Find closed form solutions and prove them correct.

(definec r1 (n :nat) :pos
  (if (zp n)
      1
    (+ (r1 (1- n)) (expt 2 n))))

; Use whatever induction scheme you like
Lemma r1-closed-form:
(= (r1 n)
   XXX)

XXX

(definec r2 (n :pos) :int
  :skip-tests t
  (match n
    (1 0)
    (2 3)
    (3 8)
    (& (+ (r2 (1- n)) (r2 (- n 2)) (- (r2 (- n 3))) 4))))

; Use whatever induction scheme you like
Lemma r2-closed-form:
(= (r2 n)
   XXX)

XXX

; After doing the above proofs, you decide to see if ACL2s can do this
; for you.
;
; Write Lemma r1-closed-form in ACL2s as a property and see if ACL2s
; can prove it automatically (use .lisp file for that).

(property (n :nat)
  (= (r1 n)
     XXX))

; Write Lemma r2-closed-form in ACL2s as a property and see if ACL2s
; can prove it automatically (use .lisp file for that).

(property (n :nat)
  (= (r2 n)
     XXX))

; This gives you an idea, which you pitch to the AI team. To test
; their system, they can use their AI solver to propose solutions to
; recurrences, which then get translated to ACL2s properties that can
; be checked using testing and/or theorem proving.
;
; They try it and find lots of bugs, ah the joys of AI.
;
; The one downside of your coop experience is you have to figure out
; whether to accept the return offer from the compiler team or the AI
; team. Which one will you choose? Tell us below. (Free points)

"XXX"|#
